# Token类别码规范文档

## 概述

本文档详细说明了C语言子集词法分析器使用的Token类别码分配方案。类别码是词法分析器输出的二元式中的第一个元素，用于标识Token的类型。

## 类别码分配原则

1. **分段管理**：将类别码分为多个段，每段对应一类Token
2. **预留空间**：每段预留足够的空间以便未来扩展
3. **语义清晰**：类别码的分配反映Token的语义分类
4. **标准兼容**：参考编译原理教材和C语言标准

## 完整类别码表

### 保留字 (1-20)

保留字是C语言中具有特殊含义的关键字，不能用作标识符。

| 类别码 | Token类型 | 关键字 | 说明 |
|--------|-----------|--------|------|
| 1 | VOID | void | 空类型 |
| 2 | INT | int | 整数类型 |
| 3 | FLOAT | float | 单精度浮点类型 |
| 4 | DOUBLE | double | 双精度浮点类型 |
| 5 | IF | if | 条件语句 |
| 6 | ELSE | else | 条件语句的else分支 |
| 7 | FOR | for | for循环 |
| 8 | DO | do | do-while循环 |
| 9 | WHILE | while | while循环 |
| 10 | RETURN | return | 函数返回 |
| 11-20 | - | - | 预留给未来扩展 |

**注意事项**：
- 关键字识别不区分大小写（统一转换为小写后查询）
- 关键字优先级高于标识符
- 预留的类别码11-20可用于添加新关键字（如char、struct、union等）

### 标识符和常量 (21-29)

| 类别码 | Token类型 | 说明 | 属性值 |
|--------|-----------|------|--------|
| 21 | IDENTIFIER | 标识符 | 标识符名称字符串 |
| 22 | INTEGER | 整数常量 | 整数值 |
| 23-29 | - | 预留 | - |

**标识符规则**：
- 必须以字母或下划线开头
- 可包含字母、数字和下划线
- 最大长度32个字符
- 区分大小写

**整数规则**：
- 仅支持无符号十进制整数
- 不支持八进制（0开头）和十六进制（0x开头）
- 不支持负数（负号作为运算符处理）

**预留空间**：
- 23: 可用于浮点数常量
- 24: 可用于字符常量
- 25: 可用于字符串常量

### 运算符 (30-59)

#### 算术运算符 (30-39)

| 类别码 | Token类型 | 符号 | 说明 |
|--------|-----------|------|------|
| 30 | PLUS | + | 加法 |
| 31 | MINUS | - | 减法 |
| 32 | MULTIPLY | * | 乘法 |
| 33 | DIVIDE | / | 除法 |
| 34 | ASSIGN | = | 赋值 |
| 35 | LT | < | 小于 |
| 36 | GT | > | 大于 |
| 37 | NOT | ! | 逻辑非 |
| 38 | INCREMENT | ++ | 自增 |
| 39 | DECREMENT | -- | 自减 |

#### 复合赋值运算符 (40-43)

| 类别码 | Token类型 | 符号 | 说明 |
|--------|-----------|------|------|
| 40 | PLUS_ASSIGN | += | 加法赋值 |
| 41 | MINUS_ASSIGN | -= | 减法赋值 |
| 42 | MULTIPLY_ASSIGN | *= | 乘法赋值 |
| 43 | DIVIDE_ASSIGN | /= | 除法赋值 |

#### 比较运算符 (44-47)

| 类别码 | Token类型 | 符号 | 说明 |
|--------|-----------|------|------|
| 44 | EQUAL | == | 等于 |
| 45 | NOT_EQUAL | != | 不等于 |
| 46 | LE | <= | 小于等于 |
| 47 | GE | >= | 大于等于 |

#### 位运算符 (48-49)

| 类别码 | Token类型 | 符号 | 说明 |
|--------|-----------|------|------|
| 48 | LEFT_SHIFT | << | 左移 |
| 49 | RIGHT_SHIFT | >> | 右移 |

#### 逻辑运算符 (50-51)

| 类别码 | Token类型 | 符号 | 说明 |
|--------|-----------|------|------|
| 50 | AND | && | 逻辑与 |
| 51 | OR | \|\| | 逻辑或 |

#### 预留运算符 (52-59)

预留给未来扩展，可用于：
- 52: % (取模)
- 53: & (按位与)
- 54: \| (按位或)
- 55: ^ (按位异或)
- 56: ~ (按位取反)
- 57: ? (三元运算符的?)
- 58: : (三元运算符的:)
- 59: -> (指针成员访问)

### 分界符 (60-69)

| 类别码 | Token类型 | 符号 | 说明 |
|--------|-----------|------|------|
| 60 | SEMICOLON | ; | 分号 |
| 61 | COMMA | , | 逗号 |
| 62 | LPAREN | ( | 左圆括号 |
| 63 | RPAREN | ) | 右圆括号 |
| 64 | LBRACE | { | 左花括号 |
| 65 | RBRACE | } | 右花括号 |
| 66-69 | - | - | 预留 |

**预留空间**：
- 66: [ (左方括号)
- 67: ] (右方括号)
- 68: . (成员访问)
- 69: # (预处理指令)

### 特殊Token (90-99, -1)

| 类别码 | Token类型 | 说明 |
|--------|-----------|------|
| 99 | EOF | 文件结束标记 |
| -1 | ERROR | 错误Token |

## 二元式格式

### 格式定义

二元式格式：`(类别码, 属性值)`

### 属性值规则

1. **关键字**：属性值为关键字本身
   - 示例：`(2, int)`, `(5, if)`

2. **标识符**：属性值为标识符名称
   - 示例：`(21, main)`, `(21, count)`

3. **整数常量**：属性值为整数值
   - 示例：`(22, 10)`, `(22, 0)`

4. **运算符**：属性值为运算符符号
   - 示例：`(30, +)`, `(38, ++)`, `(44, ==)`

5. **分界符**：属性值为分界符符号
   - 示例：`(60, ;)`, `(62, ()`, `(64, {)`

6. **EOF**：属性值为字符串"EOF"
   - 示例：`(99, EOF)`

### 完整示例

源代码：
```c
int main() {
    int x = 10;
    return 0;
}
```

二元式序列：
```
(2, int)
(21, main)
(62, ()
(63, ))
(64, {)
(2, int)
(21, x)
(34, =)
(22, 10)
(60, ;)
(10, return)
(22, 0)
(60, ;)
(65, })
(99, EOF)
```

## 运算符优先级和结合性

虽然词法分析阶段不处理优先级，但了解运算符的优先级有助于理解类别码的设计：

| 优先级 | 运算符 | 结合性 |
|--------|--------|--------|
| 1 | () | 左到右 |
| 2 | ++ -- (后缀) | 左到右 |
| 3 | ++ -- (前缀) ! | 右到左 |
| 4 | * / | 左到右 |
| 5 | + - | 左到右 |
| 6 | << >> | 左到右 |
| 7 | < <= > >= | 左到右 |
| 8 | == != | 左到右 |
| 9 | && | 左到右 |
| 10 | \|\| | 左到右 |
| 11 | = += -= *= /= | 右到左 |

## 扩展建议

### 添加新关键字

如需添加新关键字（如char、struct等）：

1. 在类别码1-20范围内选择未使用的编号
2. 在`src/token_types.h`的`TokenType`枚举中添加新类型
3. 在`src/token_types.cpp`的`KEYWORDS`映射中添加关系

示例：
```cpp
// 在 token_types.h 中
enum class TokenType {
    // ... 现有定义
    CHAR = 11,
    STRUCT = 12,
    // ...
};

// 在 token_types.cpp 中
const std::unordered_map<std::string, TokenType> KEYWORDS = {
    // ... 现有映射
    {"char", TokenType::CHAR},
    {"struct", TokenType::STRUCT},
    // ...
};
```

### 添加新运算符

如需添加新运算符：

1. 在类别码30-59范围内选择未使用的编号
2. 在`TokenType`枚举中添加新类型
3. 在`src/lexer.cpp`的`readOperator()`方法中添加识别逻辑

### 添加新常量类型

如需添加浮点数、字符常量等：

1. 在类别码21-29范围内选择未使用的编号
2. 在`src/lexer.cpp`中添加相应的识别方法（如`readFloat()`, `readChar()`）
3. 在主扫描循环中调用新方法

## 参考标准

本类别码方案参考了以下标准和教材：

1. 《编译原理》（龙书）- Alfred V. Aho等著
2. C语言标准 ISO/IEC 9899
3. 常见编译器实现（GCC、Clang等）
